{"remainingRequest":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\angular-split\\esm5\\angular-split.js","dependencies":[{"path":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\angular-split\\esm5\\angular-split.js","mtime":1512140435000},{"path":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\cache-loader\\dist\\cjs.js","mtime":0},{"path":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, ElementRef, EventEmitter, HostBinding, Input, NgModule, Output, Renderer2 } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Subject as Subject$1 } from 'rxjs/Subject';\nimport 'rxjs/add/operator/debounceTime';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * angular-split\n *\n * Areas size are set in percentage of the split container.\n * Gutters size are set in pixels.\n *\n * So we set css 'flex-basis' property like this (where 0 <= area.size <= 1):\n *  calc( { area.size * 100 }% - { area.size * nbGutter * gutterSize }px );\n *\n * Examples with 3 visible areas and 2 gutters:\n *\n * |                     10px                   10px                                  |\n * |---------------------[]---------------------[]------------------------------------|\n * |  calc(20% - 4px)          calc(20% - 4px)              calc(60% - 12px)          |\n *\n *\n * |                          10px                        10px                        |\n * |--------------------------[]--------------------------[]--------------------------|\n * |  calc(33.33% - 6.667px)      calc(33.33% - 6.667px)      calc(33.33% - 6.667px)  |\n *\n *\n * |10px                                                  10px                        |\n * |[]----------------------------------------------------[]--------------------------|\n * |0                 calc(66.66% - 13.333px)                  calc(33%% - 6.667px)   |\n *\n *\n *  10px 10px                                                                         |\n * |[][]------------------------------------------------------------------------------|\n * |0 0                               calc(100% - 20px)                               |\n *\n */\nvar SplitComponent = /*@__PURE__*/ (function () {\n    function SplitComponent(elRef, cdRef, renderer) {\n        this.elRef = elRef;\n        this.cdRef = cdRef;\n        this.renderer = renderer;\n        this._direction = 'horizontal';\n        this._useTransition = false;\n        this._disabled = false;\n        this._width = null;\n        this._height = null;\n        this._gutterSize = 11;\n        this._gutterColor = '';\n        this._gutterImageH = '';\n        this._gutterImageV = '';\n        this._dir = 'ltr';\n        this.dragStart = new EventEmitter(false);\n        this.dragProgress = new EventEmitter(false);\n        this.dragEnd = new EventEmitter(false);\n        this.gutterClick = new EventEmitter(false);\n        this.transitionEndInternal = new Subject$1();\n        this.transitionEnd = ((this.transitionEndInternal.asObservable())).debounceTime(20);\n        this.isViewInitialized = false;\n        this.isDragging = false;\n        this.draggingWithoutMove = false;\n        this.currentGutterNum = 0;\n        this.displayedAreas = [];\n        this.hidedAreas = [];\n        this.dragListeners = [];\n        this.dragStartValues = {\n            sizePixelContainer: 0,\n            sizePixelA: 0,\n            sizePixelB: 0,\n            sizePercentA: 0,\n            sizePercentB: 0,\n        };\n    }\n    Object.defineProperty(SplitComponent.prototype, \"direction\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._direction;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            var _this = this;\n            v = (v === 'vertical') ? 'vertical' : 'horizontal';\n            this._direction = v;\n            this.displayedAreas.concat(this.hidedAreas).forEach(function (area) {\n                area.comp.setStyleVisibleAndDir(area.comp.visible, _this.isDragging, _this.direction);\n            });\n            this.build(false, false);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"useTransition\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._useTransition;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            v = (typeof (v) === 'boolean') ? v : (v === 'false' ? false : true);\n            this._useTransition = v;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"disabled\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._disabled;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            v = (typeof (v) === 'boolean') ? v : (v === 'false' ? false : true);\n            this._disabled = v;\n            // Force repaint if modified from TS class (instead of the template)\n            this.cdRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"width\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._width;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            v = Number(v);\n            this._width = (!isNaN(v) && v > 0) ? v : null;\n            this.build(false, false);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"height\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._height;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            v = Number(v);\n            this._height = (!isNaN(v) && v > 0) ? v : null;\n            this.build(false, false);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"gutterSize\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._gutterSize;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            v = Number(v);\n            this._gutterSize = (!isNaN(v) && v > 0) ? v : 11;\n            this.build(false, false);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"gutterColor\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._gutterColor;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._gutterColor = (typeof v === 'string' && v !== '') ? v : '';\n            // Force repaint if modified from TS class (instead of the template)\n            this.cdRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"gutterImageH\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._gutterImageH;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._gutterImageH = (typeof v === 'string' && v !== '') ? v : '';\n            // Force repaint if modified from TS class (instead of the template)\n            this.cdRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"gutterImageV\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._gutterImageV;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._gutterImageV = (typeof v === 'string' && v !== '') ? v : '';\n            // Force repaint if modified from TS class (instead of the template)\n            this.cdRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"dir\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._dir;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            v = (v === 'rtl') ? 'rtl' : 'ltr';\n            this._dir = v;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"cssFlexdirection\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return (this.direction === 'horizontal') ? 'row' : 'column';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"cssWidth\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.width ? this.width + \"px\" : '100%';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"cssHeight\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.height ? this.height + \"px\" : '100%';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"cssMinwidth\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return (this.direction === 'horizontal') ? this.getNbGutters() * this.gutterSize + \"px\" : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitComponent.prototype, \"cssMinheight\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return (this.direction === 'vertical') ? this.getNbGutters() * this.gutterSize + \"px\" : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    SplitComponent.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            this.isViewInitialized = true;\n        };\n    /**\n     * @return {?}\n     */\n    SplitComponent.prototype.getNbGutters = /**\n     * @return {?}\n     */\n        function () {\n            return this.displayedAreas.length - 1;\n        };\n    /**\n     * @param {?} comp\n     * @return {?}\n     */\n    SplitComponent.prototype.addArea = /**\n     * @param {?} comp\n     * @return {?}\n     */\n        function (comp) {\n            var /** @type {?} */ newArea = {\n                comp: comp,\n                order: 0,\n                size: 0,\n            };\n            if (comp.visible === true) {\n                this.displayedAreas.push(newArea);\n            }\n            else {\n                this.hidedAreas.push(newArea);\n            }\n            comp.setStyleVisibleAndDir(comp.visible, this.isDragging, this.direction);\n            this.build(true, true);\n        };\n    /**\n     * @param {?} comp\n     * @return {?}\n     */\n    SplitComponent.prototype.removeArea = /**\n     * @param {?} comp\n     * @return {?}\n     */\n        function (comp) {\n            if (this.displayedAreas.some(function (a) { return a.comp === comp; })) {\n                var /** @type {?} */ area = (this.displayedAreas.find(function (a) { return a.comp === comp; }));\n                this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);\n                this.build(true, true);\n            }\n            else if (this.hidedAreas.some(function (a) { return a.comp === comp; })) {\n                var /** @type {?} */ area = (this.hidedAreas.find(function (a) { return a.comp === comp; }));\n                this.hidedAreas.splice(this.hidedAreas.indexOf(area), 1);\n            }\n        };\n    /**\n     * @param {?} comp\n     * @param {?} resetOrders\n     * @param {?} resetSizes\n     * @return {?}\n     */\n    SplitComponent.prototype.updateArea = /**\n     * @param {?} comp\n     * @param {?} resetOrders\n     * @param {?} resetSizes\n     * @return {?}\n     */\n        function (comp, resetOrders, resetSizes) {\n            // Only refresh if area is displayed (No need to check inside 'hidedAreas')\n            var /** @type {?} */ item = this.displayedAreas.find(function (a) { return a.comp === comp; });\n            if (item) {\n                this.build(resetOrders, resetSizes);\n            }\n        };\n    /**\n     * @param {?} comp\n     * @return {?}\n     */\n    SplitComponent.prototype.showArea = /**\n     * @param {?} comp\n     * @return {?}\n     */\n        function (comp) {\n            var /** @type {?} */ area = this.hidedAreas.find(function (a) { return a.comp === comp; });\n            if (area) {\n                comp.setStyleVisibleAndDir(comp.visible, this.isDragging, this.direction);\n                var /** @type {?} */ areas = this.hidedAreas.splice(this.hidedAreas.indexOf(area), 1);\n                (_a = this.displayedAreas).push.apply(_a, areas);\n                this.build(true, true);\n            }\n            var _a;\n        };\n    /**\n     * @param {?} comp\n     * @return {?}\n     */\n    SplitComponent.prototype.hideArea = /**\n     * @param {?} comp\n     * @return {?}\n     */\n        function (comp) {\n            var /** @type {?} */ area = this.displayedAreas.find(function (a) { return a.comp === comp; });\n            if (area) {\n                comp.setStyleVisibleAndDir(comp.visible, this.isDragging, this.direction);\n                var /** @type {?} */ areas = this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);\n                areas.forEach(function (area) {\n                    area.order = 0;\n                    area.size = 0;\n                });\n                (_a = this.hidedAreas).push.apply(_a, areas);\n                this.build(true, true);\n            }\n            var _a;\n        };\n    /**\n     * @param {?} resetOrders\n     * @param {?} resetSizes\n     * @return {?}\n     */\n    SplitComponent.prototype.build = /**\n     * @param {?} resetOrders\n     * @param {?} resetSizes\n     * @return {?}\n     */\n        function (resetOrders, resetSizes) {\n            var _this = this;\n            this.stopDragging();\n            // ¤ AREAS ORDER\n            if (resetOrders === true) {\n                // If user provided 'order' for each area, use it to sort them.\n                if (this.displayedAreas.every(function (a) { return a.comp.order !== null; })) {\n                    this.displayedAreas.sort(function (a, b) { return ((a.comp.order)) - ((b.comp.order)); });\n                }\n                // Then set real order with multiples of 2, numbers between will be used by gutters.\n                this.displayedAreas.forEach(function (area, i) {\n                    area.order = i * 2;\n                    area.comp.setStyleOrder(area.order);\n                });\n            }\n            // ¤ AREAS SIZE PERCENT\n            if (resetSizes === true) {\n                var /** @type {?} */ totalUserSize = (this.displayedAreas.reduce(function (total, s) { return s.comp.size ? total + s.comp.size : total; }, 0));\n                // If user provided 'size' for each area and total == 1, use it.\n                if (this.displayedAreas.every(function (a) { return a.comp.size !== null; }) && totalUserSize > .999 && totalUserSize < 1.001) {\n                    this.displayedAreas.forEach(function (area) {\n                        area.size = /** @type {?} */ (area.comp.size);\n                    });\n                }\n                else {\n                    var /** @type {?} */ size_1 = 1 / this.displayedAreas.length;\n                    this.displayedAreas.forEach(function (area) {\n                        area.size = size_1;\n                    });\n                }\n            }\n            // ¤\n            // If some real area sizes are less than gutterSize,\n            // set them to zero and dispatch size to others.\n            var /** @type {?} */ percentToDispatch = 0;\n            // Get container pixel size\n            var /** @type {?} */ containerSizePixel = this.getNbGutters() * this.gutterSize;\n            if (this.direction === 'horizontal') {\n                containerSizePixel = this.width ? this.width : this.elRef.nativeElement['offsetWidth'];\n            }\n            else {\n                containerSizePixel = this.height ? this.height : this.elRef.nativeElement['offsetHeight'];\n            }\n            this.displayedAreas.forEach(function (area) {\n                if (area.size * containerSizePixel < _this.gutterSize) {\n                    percentToDispatch += area.size;\n                    area.size = 0;\n                }\n            });\n            if (percentToDispatch > 0 && this.displayedAreas.length > 0) {\n                var /** @type {?} */ nbAreasNotZero = this.displayedAreas.filter(function (a) { return a.size !== 0; }).length;\n                if (nbAreasNotZero > 0) {\n                    var /** @type {?} */ percentToAdd_1 = percentToDispatch / nbAreasNotZero;\n                    this.displayedAreas.filter(function (a) { return a.size !== 0; }).forEach(function (area) {\n                        area.size += percentToAdd_1;\n                    });\n                }\n                else {\n                    this.displayedAreas[this.displayedAreas.length - 1].size = 1;\n                }\n            }\n            this.refreshStyleSizes();\n            this.cdRef.markForCheck();\n        };\n    /**\n     * @return {?}\n     */\n    SplitComponent.prototype.refreshStyleSizes = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            var /** @type {?} */ sumGutterSize = this.getNbGutters() * this.gutterSize;\n            this.displayedAreas.forEach(function (area) {\n                area.comp.setStyleFlexbasis(\"calc( \" + area.size * 100 + \"% - \" + area.size * sumGutterSize + \"px )\", _this.isDragging);\n            });\n        };\n    /**\n     * @param {?} startEvent\n     * @param {?} gutterOrder\n     * @param {?} gutterNum\n     * @return {?}\n     */\n    SplitComponent.prototype.startDragging = /**\n     * @param {?} startEvent\n     * @param {?} gutterOrder\n     * @param {?} gutterNum\n     * @return {?}\n     */\n        function (startEvent, gutterOrder, gutterNum) {\n            var _this = this;\n            startEvent.preventDefault();\n            // Place code here to allow '(gutterClick)' event even if '[disabled]=\"true\"'.\n            this.currentGutterNum = gutterNum;\n            this.draggingWithoutMove = true;\n            this.dragListeners.push(this.renderer.listen('document', 'mouseup', function (e) { return _this.stopDragging(); }));\n            this.dragListeners.push(this.renderer.listen('document', 'touchend', function (e) { return _this.stopDragging(); }));\n            this.dragListeners.push(this.renderer.listen('document', 'touchcancel', function (e) { return _this.stopDragging(); }));\n            if (this.disabled) {\n                return;\n            }\n            var /** @type {?} */ areaA = this.displayedAreas.find(function (a) { return a.order === gutterOrder - 1; });\n            var /** @type {?} */ areaB = this.displayedAreas.find(function (a) { return a.order === gutterOrder + 1; });\n            if (!areaA || !areaB) {\n                return;\n            }\n            var /** @type {?} */ prop = (this.direction === 'horizontal') ? 'offsetWidth' : 'offsetHeight';\n            this.dragStartValues.sizePixelContainer = this.elRef.nativeElement[prop];\n            this.dragStartValues.sizePixelA = areaA.comp.getSizePixel(prop);\n            this.dragStartValues.sizePixelB = areaB.comp.getSizePixel(prop);\n            this.dragStartValues.sizePercentA = areaA.size;\n            this.dragStartValues.sizePercentB = areaB.size;\n            var /** @type {?} */ start;\n            if (startEvent instanceof MouseEvent) {\n                start = {\n                    x: startEvent.screenX,\n                    y: startEvent.screenY,\n                };\n            }\n            else if (startEvent instanceof TouchEvent) {\n                start = {\n                    x: startEvent.touches[0].screenX,\n                    y: startEvent.touches[0].screenY,\n                };\n            }\n            else {\n                return;\n            }\n            this.dragListeners.push(this.renderer.listen('document', 'mousemove', function (e) { return _this.dragEvent(e, start, areaA, areaB); }));\n            this.dragListeners.push(this.renderer.listen('document', 'touchmove', function (e) { return _this.dragEvent(e, start, areaA, areaB); }));\n            areaA.comp.lockEvents();\n            areaB.comp.lockEvents();\n            this.isDragging = true;\n            this.notify('start');\n        };\n    /**\n     * @param {?} event\n     * @param {?} start\n     * @param {?} areaA\n     * @param {?} areaB\n     * @return {?}\n     */\n    SplitComponent.prototype.dragEvent = /**\n     * @param {?} event\n     * @param {?} start\n     * @param {?} areaA\n     * @param {?} areaB\n     * @return {?}\n     */\n        function (event, start, areaA, areaB) {\n            if (!this.isDragging) {\n                return;\n            }\n            var /** @type {?} */ end;\n            if (event instanceof MouseEvent) {\n                end = {\n                    x: event.screenX,\n                    y: event.screenY,\n                };\n            }\n            else if (event instanceof TouchEvent) {\n                end = {\n                    x: event.touches[0].screenX,\n                    y: event.touches[0].screenY,\n                };\n            }\n            else {\n                return;\n            }\n            this.draggingWithoutMove = false;\n            this.drag(start, end, areaA, areaB);\n        };\n    /**\n     * @param {?} start\n     * @param {?} end\n     * @param {?} areaA\n     * @param {?} areaB\n     * @return {?}\n     */\n    SplitComponent.prototype.drag = /**\n     * @param {?} start\n     * @param {?} end\n     * @param {?} areaA\n     * @param {?} areaB\n     * @return {?}\n     */\n        function (start, end, areaA, areaB) {\n            // ¤ AREAS SIZE PIXEL\n            var /** @type {?} */ offsetPixel = (this.direction === 'horizontal') ? (start.x - end.x) : (start.y - end.y);\n            if (this.dir === 'rtl') {\n                offsetPixel = -offsetPixel;\n            }\n            var /** @type {?} */ newSizePixelA = this.dragStartValues.sizePixelA - offsetPixel;\n            var /** @type {?} */ newSizePixelB = this.dragStartValues.sizePixelB + offsetPixel;\n            if (newSizePixelA < this.gutterSize && newSizePixelB < this.gutterSize) {\n                // WTF.. get out of here!\n                return;\n            }\n            else if (newSizePixelA < this.gutterSize) {\n                newSizePixelB += newSizePixelA;\n                newSizePixelA = 0;\n            }\n            else if (newSizePixelB < this.gutterSize) {\n                newSizePixelA += newSizePixelB;\n                newSizePixelB = 0;\n            }\n            // ¤ AREAS SIZE PERCENT\n            if (newSizePixelA === 0) {\n                areaB.size += areaA.size;\n                areaA.size = 0;\n            }\n            else if (newSizePixelB === 0) {\n                areaA.size += areaB.size;\n                areaB.size = 0;\n            }\n            else {\n                // NEW_PERCENT = START_PERCENT / START_PIXEL * NEW_PIXEL;\n                if (this.dragStartValues.sizePercentA === 0) {\n                    areaB.size = this.dragStartValues.sizePercentB / this.dragStartValues.sizePixelB * newSizePixelB;\n                    areaA.size = this.dragStartValues.sizePercentB - areaB.size;\n                }\n                else if (this.dragStartValues.sizePercentB === 0) {\n                    areaA.size = this.dragStartValues.sizePercentA / this.dragStartValues.sizePixelA * newSizePixelA;\n                    areaB.size = this.dragStartValues.sizePercentA - areaA.size;\n                }\n                else {\n                    areaA.size = this.dragStartValues.sizePercentA / this.dragStartValues.sizePixelA * newSizePixelA;\n                    areaB.size = (this.dragStartValues.sizePercentA + this.dragStartValues.sizePercentB) - areaA.size;\n                }\n            }\n            this.refreshStyleSizes();\n            this.notify('progress');\n        };\n    /**\n     * @return {?}\n     */\n    SplitComponent.prototype.stopDragging = /**\n     * @return {?}\n     */\n        function () {\n            if (this.isDragging === false && this.draggingWithoutMove === false) {\n                return;\n            }\n            this.displayedAreas.forEach(function (area) {\n                area.comp.unlockEvents();\n            });\n            while (this.dragListeners.length > 0) {\n                var /** @type {?} */ fct = this.dragListeners.pop();\n                if (fct) {\n                    fct();\n                }\n            }\n            if (this.draggingWithoutMove === true) {\n                this.notify('click');\n            }\n            else {\n                this.notify('end');\n            }\n            this.isDragging = false;\n            this.draggingWithoutMove = false;\n        };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    SplitComponent.prototype.notify = /**\n     * @param {?} type\n     * @return {?}\n     */\n        function (type) {\n            var /** @type {?} */ areasSize = this.displayedAreas.map(function (a) { return a.size * 100; });\n            switch (type) {\n                case 'start':\n                    return this.dragStart.emit({ gutterNum: this.currentGutterNum, sizes: areasSize });\n                case 'progress':\n                    return this.dragProgress.emit({ gutterNum: this.currentGutterNum, sizes: areasSize });\n                case 'end':\n                    return this.dragEnd.emit({ gutterNum: this.currentGutterNum, sizes: areasSize });\n                case 'click':\n                    return this.gutterClick.emit({ gutterNum: this.currentGutterNum, sizes: areasSize });\n                case 'transitionEnd':\n                    return this.transitionEndInternal.next(areasSize);\n            }\n        };\n    /**\n     * @return {?}\n     */\n    SplitComponent.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.stopDragging();\n        };\n    return SplitComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar SplitAreaDirective = /*@__PURE__*/ (function () {\n    function SplitAreaDirective(elRef, renderer, split) {\n        this.elRef = elRef;\n        this.renderer = renderer;\n        this.split = split;\n        this._order = null;\n        this._size = null;\n        this._minSize = 0;\n        this._visible = true;\n        this.lockListeners = [];\n    }\n    Object.defineProperty(SplitAreaDirective.prototype, \"order\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._order;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            v = Number(v);\n            this._order = !isNaN(v) ? v : null;\n            this.split.updateArea(this, true, false);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitAreaDirective.prototype, \"size\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._size;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            v = Number(v);\n            this._size = (!isNaN(v) && v >= 0 && v <= 100) ? (v / 100) : null;\n            this.split.updateArea(this, false, true);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitAreaDirective.prototype, \"minSize\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._minSize;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            v = Number(v);\n            this._minSize = (!isNaN(v) && v > 0 && v < 100) ? v / 100 : 0;\n            this.split.updateArea(this, false, true);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitAreaDirective.prototype, \"visible\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._visible;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            v = (typeof (v) === 'boolean') ? v : (v === 'false' ? false : true);\n            this._visible = v;\n            if (this.visible) {\n                this.split.showArea(this);\n            }\n            else {\n                this.split.hideArea(this);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    SplitAreaDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.split.addArea(this);\n            this.renderer.setStyle(this.elRef.nativeElement, 'flex-grow', '0');\n            this.renderer.setStyle(this.elRef.nativeElement, 'flex-shrink', '0');\n            this.transitionListener = this.renderer.listen(this.elRef.nativeElement, 'transitionend', function (e) { return _this.onTransitionEnd(e); });\n        };\n    /**\n     * @param {?} prop\n     * @return {?}\n     */\n    SplitAreaDirective.prototype.getSizePixel = /**\n     * @param {?} prop\n     * @return {?}\n     */\n        function (prop) {\n            return this.elRef.nativeElement[prop];\n        };\n    /**\n     * @param {?} isVisible\n     * @param {?} isDragging\n     * @param {?} direction\n     * @return {?}\n     */\n    SplitAreaDirective.prototype.setStyleVisibleAndDir = /**\n     * @param {?} isVisible\n     * @param {?} isDragging\n     * @param {?} direction\n     * @return {?}\n     */\n        function (isVisible, isDragging, direction) {\n            if (isVisible === false) {\n                this.setStyleFlexbasis('0', isDragging);\n                this.renderer.setStyle(this.elRef.nativeElement, 'overflow-x', 'hidden');\n                this.renderer.setStyle(this.elRef.nativeElement, 'overflow-y', 'hidden');\n                if (direction === 'vertical') {\n                    this.renderer.setStyle(this.elRef.nativeElement, 'max-width', '0');\n                }\n            }\n            else {\n                this.renderer.setStyle(this.elRef.nativeElement, 'overflow-x', 'hidden');\n                this.renderer.setStyle(this.elRef.nativeElement, 'overflow-y', 'auto');\n                this.renderer.removeStyle(this.elRef.nativeElement, 'max-width');\n            }\n            if (direction === 'horizontal') {\n                this.renderer.setStyle(this.elRef.nativeElement, 'height', '100%');\n                this.renderer.removeStyle(this.elRef.nativeElement, 'width');\n            }\n            else {\n                this.renderer.setStyle(this.elRef.nativeElement, 'width', '100%');\n                this.renderer.removeStyle(this.elRef.nativeElement, 'height');\n            }\n        };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    SplitAreaDirective.prototype.setStyleOrder = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            this.renderer.setStyle(this.elRef.nativeElement, 'order', value);\n        };\n    /**\n     * @param {?} value\n     * @param {?} isDragging\n     * @return {?}\n     */\n    SplitAreaDirective.prototype.setStyleFlexbasis = /**\n     * @param {?} value\n     * @param {?} isDragging\n     * @return {?}\n     */\n        function (value, isDragging) {\n            // If component not yet initialized or gutter being dragged, disable transition\n            if (this.split.isViewInitialized === false || isDragging === true) {\n                this.setStyleTransition(false);\n            }\n            else {\n                this.setStyleTransition(this.split.useTransition);\n            }\n            this.renderer.setStyle(this.elRef.nativeElement, 'flex-basis', value);\n        };\n    /**\n     * @param {?} useTransition\n     * @return {?}\n     */\n    SplitAreaDirective.prototype.setStyleTransition = /**\n     * @param {?} useTransition\n     * @return {?}\n     */\n        function (useTransition) {\n            if (useTransition) {\n                this.renderer.setStyle(this.elRef.nativeElement, 'transition', \"flex-basis 0.3s\");\n            }\n            else {\n                this.renderer.removeStyle(this.elRef.nativeElement, 'transition');\n            }\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    SplitAreaDirective.prototype.onTransitionEnd = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // Limit only flex-basis transition to trigger the event\n            if (event.propertyName === 'flex-basis') {\n                this.split.notify('transitionEnd');\n            }\n        };\n    /**\n     * @return {?}\n     */\n    SplitAreaDirective.prototype.lockEvents = /**\n     * @return {?}\n     */\n        function () {\n            this.lockListeners.push(this.renderer.listen(this.elRef.nativeElement, 'selectstart', function (e) { return false; }));\n            this.lockListeners.push(this.renderer.listen(this.elRef.nativeElement, 'dragstart', function (e) { return false; }));\n        };\n    /**\n     * @return {?}\n     */\n    SplitAreaDirective.prototype.unlockEvents = /**\n     * @return {?}\n     */\n        function () {\n            while (this.lockListeners.length > 0) {\n                var /** @type {?} */ fct = this.lockListeners.pop();\n                if (fct) {\n                    fct();\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    SplitAreaDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.unlockEvents();\n            if (this.transitionListener) {\n                this.transitionListener();\n            }\n            this.split.removeArea(this);\n        };\n    return SplitAreaDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar SplitGutterDirective = /*@__PURE__*/ (function () {\n    ////\n    function SplitGutterDirective(elRef, renderer) {\n        this.elRef = elRef;\n        this.renderer = renderer;\n        this._disabled = false;\n    }\n    Object.defineProperty(SplitGutterDirective.prototype, \"order\", {\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this.renderer.setStyle(this.elRef.nativeElement, 'order', v);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitGutterDirective.prototype, \"direction\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._direction;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._direction = v;\n            this.refreshStyle();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitGutterDirective.prototype, \"useTransition\", {\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            if (v) {\n                this.renderer.setStyle(this.elRef.nativeElement, 'transition', \"flex-basis 0.3s\");\n            }\n            else {\n                this.renderer.removeStyle(this.elRef.nativeElement, 'transition');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitGutterDirective.prototype, \"size\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._size;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._size = v;\n            this.refreshStyle();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitGutterDirective.prototype, \"color\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._color;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._color = v;\n            this.refreshStyle();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitGutterDirective.prototype, \"imageH\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._imageH;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._imageH = v;\n            this.refreshStyle();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitGutterDirective.prototype, \"imageV\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._imageV;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._imageV = v;\n            this.refreshStyle();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitGutterDirective.prototype, \"disabled\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._disabled;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._disabled = v;\n            this.refreshStyle();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    SplitGutterDirective.prototype.refreshStyle = /**\n     * @return {?}\n     */\n        function () {\n            this.renderer.setStyle(this.elRef.nativeElement, 'flex-basis', this.size + \"px\");\n            // fix safari bug about gutter height when direction is horizontal\n            this.renderer.setStyle(this.elRef.nativeElement, 'height', (this.direction === 'vertical') ? this.size + \"px\" : \"100%\");\n            this.renderer.setStyle(this.elRef.nativeElement, 'background-color', (this.color !== '') ? this.color : \"#eeeeee\");\n            var /** @type {?} */ state = (this.disabled === true) ? 'disabled' : this.direction;\n            this.renderer.setStyle(this.elRef.nativeElement, 'background-image', this.getImage(state));\n            this.renderer.setStyle(this.elRef.nativeElement, 'cursor', this.getCursor(state));\n        };\n    /**\n     * @param {?} state\n     * @return {?}\n     */\n    SplitGutterDirective.prototype.getCursor = /**\n     * @param {?} state\n     * @return {?}\n     */\n        function (state) {\n            switch (state) {\n                case 'horizontal':\n                    return 'col-resize';\n                case 'vertical':\n                    return 'row-resize';\n                case 'disabled':\n                    return 'default';\n            }\n        };\n    /**\n     * @param {?} state\n     * @return {?}\n     */\n    SplitGutterDirective.prototype.getImage = /**\n     * @param {?} state\n     * @return {?}\n     */\n        function (state) {\n            switch (state) {\n                case 'horizontal':\n                    return (this.imageH !== '') ? this.imageH : defaultImageH;\n                case 'vertical':\n                    return (this.imageV !== '') ? this.imageV : defaultImageV;\n                case 'disabled':\n                    return '';\n            }\n        };\n    return SplitGutterDirective;\n}());\nvar defaultImageH = 'url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==\")';\nvar defaultImageV = 'url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFCAMAAABl/6zIAAAABlBMVEUAAADMzMzIT8AyAAAAAXRSTlMAQObYZgAAABRJREFUeAFjYGRkwIMJSeMHlBkOABP7AEGzSuPKAAAAAElFTkSuQmCC\")';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar AngularSplitModule = /*@__PURE__*/ (function () {\n    function AngularSplitModule() {\n    }\n    /**\n     * @return {?}\n     */\n    AngularSplitModule.forRoot = /**\n     * @return {?}\n     */\n        function () {\n            return {\n                ngModule: AngularSplitModule,\n                providers: []\n            };\n        };\n    /**\n     * @return {?}\n     */\n    AngularSplitModule.forChild = /**\n     * @return {?}\n     */\n        function () {\n            return {\n                ngModule: AngularSplitModule,\n                providers: []\n            };\n        };\n    return AngularSplitModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Public classes.\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Entry point for all public APIs of the package.\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { AngularSplitModule, SplitComponent, SplitAreaDirective, SplitGutterDirective as ɵa };\n//# sourceMappingURL=angular-split.js.map\n",null]}